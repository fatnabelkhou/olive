{"ast":null,"code":"import _slicedToArray from \"C:/Users/DELL/Desktop/fatna belkhou/O-Live-master/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"C:/Users/DELL/Desktop/fatna belkhou/O-Live-master/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, NgModule } from '@angular/core';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nvar proxyPolyfillCompat = {\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\nvar USE_EMULATOR = new InjectionToken('angularfire2.auth.use-emulator');\nvar SETTINGS = new InjectionToken('angularfire2.auth.settings');\nvar TENANT_ID = new InjectionToken('angularfire2.auth.tenant-id');\nvar LANGUAGE_CODE = new InjectionToken('angularfire2.auth.langugage-code');\nvar USE_DEVICE_LANGUAGE = new InjectionToken('angularfire2.auth.use-device-language');\nvar PERSISTENCE = new InjectionToken('angularfire.auth.persistence');\n\nvar AngularFireAuth = /*@__PURE__*/function () {\n  var AngularFireAuth = function AngularFireAuth(options, nameOrConfig, // tslint:disable-next-line:ban-types\n  platformId, zone, _useEmulator, // can't use the tuple here\n  _settings, // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence) {\n    _classCallCheck(this, AngularFireAuth);\n\n    var schedulers = new ɵAngularFireSchedulers(zone);\n    var keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(schedulers);\n    var logins = new Subject();\n    var auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(function () {\n      return zone.runOutsideAngular(function () {\n        return import('firebase/auth');\n      });\n    }), map(function () {\n      return ɵfirebaseAppFactory(options, zone, nameOrConfig);\n    }), map(function (app) {\n      return zone.runOutsideAngular(function () {\n        var useEmulator = _useEmulator;\n        var settings = _settings;\n        return ɵfetchInstance(\"\".concat(app.name, \".auth\"), 'AngularFireAuth', app, function () {\n          var auth = zone.runOutsideAngular(function () {\n            return app.auth();\n          });\n\n          if (useEmulator) {\n            // Firebase Auth doesn't conform to the useEmulator convention, let's smooth that over\n            auth.useEmulator(\"http://\".concat(useEmulator.join(':')));\n          }\n\n          if (tenantId) {\n            auth.tenantId = tenantId;\n          }\n\n          auth.languageCode = languageCode;\n\n          if (useDeviceLanguage) {\n            auth.useDeviceLanguage();\n          }\n\n          if (settings) {\n            for (var _i = 0, _Object$entries = Object.entries(settings); _i < _Object$entries.length; _i++) {\n              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                  k = _Object$entries$_i[0],\n                  v = _Object$entries$_i[1];\n\n              auth.settings[k] = v;\n            }\n          }\n\n          if (persistence) {\n            auth.setPersistence(persistence);\n          }\n\n          return auth;\n        }, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\n      });\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: false\n    }));\n\n    if (isPlatformServer(platformId)) {\n      this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n    } else {\n      // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n      //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly\n      //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n      //       There could potentially be race conditions still... but this greatly decreases the odds while\n      //       we reevaluate the API.\n      var _ = auth.pipe(first()).subscribe();\n\n      var redirectResult = auth.pipe(switchMap(function (auth) {\n        return auth.getRedirectResult().then(function (it) {\n          return it;\n        }, function () {\n          return null;\n        });\n      }), keepUnstableUntilFirst, shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n\n      var fromCallback = function fromCallback(cb) {\n        return new Observable(function (subscriber) {\n          return {\n            unsubscribe: zone.runOutsideAngular(function () {\n              return cb(subscriber);\n            })\n          };\n        });\n      };\n\n      var authStateChanged = auth.pipe(switchMap(function (auth) {\n        return fromCallback(auth.onAuthStateChanged.bind(auth));\n      }));\n      var idTokenChanged = auth.pipe(switchMap(function (auth) {\n        return fromCallback(auth.onIdTokenChanged.bind(auth));\n      }));\n      this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.idToken = this.user.pipe(switchMap(function (user) {\n        return user ? from(user.getIdToken()) : of(null);\n      }));\n      this.idTokenResult = this.user.pipe(switchMap(function (user) {\n        return user ? from(user.getIdTokenResult()) : of(null);\n      }));\n      this.credential = merge(redirectResult, logins, // pipe in null authState to make credential zipable, just a weird devexp if\n      // authState and user go null to still have a credential\n      this.authState.pipe(filter(function (it) {\n        return !it;\n      }))).pipe( // handle the { user: { } } when a user is already logged in, rather have null\n      // TODO handle the type corcersion better\n      map(function (credential) {\n        return (credential === null || credential === void 0 ? void 0 : credential.user) ? credential : null;\n      }), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n    }\n\n    return ɵlazySDKProxy(this, auth, zone, {\n      spy: {\n        apply: function apply(name, _, val) {\n          // If they call a signIn or createUser function listen into the promise\n          // this will give us the user credential, push onto the logins Subject\n          // to be consumed in .credential\n          if (name.startsWith('signIn') || name.startsWith('createUser')) {\n            // TODO fix the types, the trouble is UserCredential has everything optional\n            val.then(function (user) {\n              return logins.next(user);\n            });\n          }\n        }\n      }\n    });\n  };\n\n  AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {\n    return new (t || AngularFireAuth)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(USE_EMULATOR, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(TENANT_ID, 8), ɵngcc0.ɵɵinject(LANGUAGE_CODE, 8), ɵngcc0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), ɵngcc0.ɵɵinject(PERSISTENCE, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireAuth.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AngularFireAuth_Factory() {\n      return new AngularFireAuth(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8));\n    },\n    token: AngularFireAuth,\n    providedIn: \"any\"\n  });\n  return AngularFireAuth;\n}();\n\nɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);\n\nvar AngularFireAuthModule = /*@__PURE__*/function () {\n  var AngularFireAuthModule = function AngularFireAuthModule() {\n    _classCallCheck(this, AngularFireAuthModule);\n  };\n\n  AngularFireAuthModule.ɵfac = function AngularFireAuthModule_Factory(t) {\n    return new (t || AngularFireAuthModule)();\n  };\n\n  AngularFireAuthModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireAuthModule\n  });\n  AngularFireAuthModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [AngularFireAuth]\n  });\n  return AngularFireAuthModule;\n}();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR }; //# sourceMappingURL=angular-fire-auth.js.map","map":null,"metadata":{},"sourceType":"module"}